using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Threading;

namespace SecretHitler {
    /// <summary>
    /// Yet to implement-
    ///     Election tracker
    ///     Hitler elected win condition
    ///     Hitler Knows
    ///     
    /// </summary>
    public static class GameManager {
        public static SIZE gameSize;
        
        public static GAMESTATES gameState = GAMESTATES.NOT_STARTED;

        private static PoliciesDeck policies = new PoliciesDeck();

        private static PlayerLogic[] players;

        private static int PrevPrez = -1;     // For selecting special elections and chancellor selection
        private static int CurrentPrez = -1;  // For Drawing cards
        private static int NextPrez = -1;     // For president cycle
        private static int PrevChan = -1;     // For selecting chancellor
        private static int CurrentChan = -1;  // For Passing cards

        /// <summary>
        /// Adds player to array of players, will fail if game has already started
        /// ID is autogenerated
        /// </summary>
        /// <param name="Name">Display name of player</param>
        /// <returns>Successfully added player</returns>
        public static bool AddPlayer(string Name) {
            if (gameState != GAMESTATES.NOT_STARTED) {
                PlayerLogic[] newPlayerList = new PlayerLogic[PlayerCount() + 1];
                for (int i = 0; i < PlayerCount(); i++) {
                    newPlayerList[i] = players[i];
                }
                newPlayerList[PlayerCount()] = new PlayerLogic(PlayerCount(), Name);
                players = newPlayerList;
                return true;
            } else {
                return false;
            }
        }

        /// <summary>
        /// Used once all players have joined lobby
        /// </summary>
        public static void GameStart() {
            int playercount = PlayerCount();
            if (playercount < 5)
                return; // Too few players
            else if (playercount < 7)
                gameSize = SIZE.SML;
            else if (playercount < 9)
                gameSize = SIZE.MED;
            else if (playercount < 11)
                gameSize = SIZE.LGE;
            else
                return; // Too many players

            int[] randomPlayers = new int[playercount];
            for(int i = 0; i < playercount; i++) {
                randomPlayers[i] = i;
            }
            randomPlayers.Shuffle();

            int pIndex = 0;
            //Set Hitler
            players[randomPlayers[pIndex]].Role = ROLES.Hitler;
            pIndex++;
            //Set fascists
            int numFascists = (playercount - 3) / 2;
            while (pIndex < numFascists) {
                players[randomPlayers[pIndex]].Role = ROLES.Fascist;
                pIndex++;
            }
            //Set remaining as Liberal
            while (pIndex < playercount) {
                players[randomPlayers[pIndex]].Role = ROLES.Liberal;
                pIndex++;
            }
            //Reset deck of cards
            policies = new PoliciesDeck();
            //Clear boards
            Boards.ClearAll();
            //Randomly select president
            System.Random rand = new System.Random();
            CurrentPrez = rand.Next(0, playercount - 1);
            SetNewNextPres(CurrentPrez+1);
            //No need to make users communicate roles, as info will be available on devices

            gameState = GAMESTATES.SELECTING_CHAN;
        }

        //----------------------------------GAME LOOP---------------------------------

        public static void Update() {
            switch (gameState) {
                case GAMESTATES.VOTING:
                    int voteTotal = 0;
                    for (int i = 0; i < PlayerCount(); i++) {
                        if (!players[i].HasVoted)
                            return;
                        if (players[i].Vote == Utility.JA)
                            voteTotal++;
                        else
                            voteTotal--;
                    }
                    if(voteTotal > 0) {
                        StartPres_Policy();
                    } else {
                        SetPres();
                    }
                    break;
                case GAMESTATES.PRES_POLICY:
                    if (players[CurrentPrez].Hand.Count < 3) {
                        StartChan_Policy();
                    }
                    break;
                case GAMESTATES.CHAN_POLICY:
                    if (players[CurrentPrez].Hand.Count < 2) {
                        bool CardPlayed = players[CurrentChan].Hand[0];
                        players[CurrentChan].Hand.Clear();
                        PlayCard(CardPlayed);
                    }
                    break;
                case GAMESTATES.VETOING:
                    //Has the president decided to agree to veto
                    //SetPres if vetoed, PlayCard if not
                    break;
            }
        }

        private static void SetPres() {
            CurrentPrez = NextPrez;
            SetNewNextPres(CurrentPrez + 1);
            gameState = GAMESTATES.SELECTING_CHAN;
        }

        private static int SetNewNextPres(int nextPresID) {
            NextPrez = nextPresID % PlayerCount();
            return NextPrez;
        }

        private static void StartPres_Policy() {
            players[CurrentPrez].Hand = policies.drawCards(3);
        }

        private static void StartChan_Policy() {
            players[CurrentChan].Hand = players[CurrentPrez].Hand;
        }

        private static void PlayCard(bool c) {
            PrevChan = CurrentChan;
            PrevPrez = CurrentPrez;

            if (c == Utility.FASCIST) {
                Boards.FascistBoards[(int)gameSize].CardsPlayed++;
                if (Boards.FascistBoards[(int)gameSize].CardsPlayed == Boards.FascistBoards[(int)gameSize].BoardLength()) {
                    EndGame(Utility.FASCIST);
                }
                ResolvePowers(Boards.FascistBoards[(int)gameSize].GetPower());
             } else {
                Boards.LiberalBoard.CardsPlayed++;
                if (Boards.LiberalBoard.CardsPlayed == Boards.LiberalBoard.BoardLength()) {
                    EndGame(Utility.LIBERAL);
                }
                ResolvePowers (Boards.LiberalBoard.GetPower());
            }
        }

        private static void ResolvePowers (POWERS p) {
            switch (p) {
                case POWERS.LoyaltyCheck:
                    gameState = GAMESTATES.LOYALTY_CHECK;
                    break;
                case POWERS.SpecialElection:
                    gameState = GAMESTATES.SPECIAL_ELECTION;
                    break;
                case POWERS.PolicyCheck:
                    gameState = GAMESTATES.POLICY_PEEK;
                    players[CurrentPrez].Hand = policies.showTopThree();
                    break;
                case POWERS.Assassination:
                    gameState = GAMESTATES.ASSASSINATE;
                    break;
                default:
                    SetPres();
                    break;
            }
        }

        private static void EndGame(bool whoWon) {
            gameState = GAMESTATES.ENDED;
        }

        //-----------------------------------ACTIONS----------------------------------

        public static void DiscardCard (int PlayerID, int index) {
            policies.discard(players[PlayerID].Hand[index]);
            players[PlayerID].Hand.Remove(players[PlayerID].Hand[index]);
        }

        public static void KillPlayer(int PlayerID) {
            //If is hitler, end game
            //Else, set them as dead and move on to set next pres
        }

        public static void ChooseChancellor(int PlayerID) {
            CurrentChan = PlayerID;
            gameState = GAMESTATES.VOTING;
            foreach (PlayerLogic p in players)
                p.HasVoted = false;
        }

        public static void ChoosePresident(int PlayerID) {
            CurrentPrez = PlayerID;
            gameState = GAMESTATES.SELECTING_CHAN;
        }

        public static void Vote (int PlayerID, bool vote) {
            players[PlayerID].Vote = vote;
        }

        public static void EndPolicyPeek () {
            players[CurrentPrez].Hand.Clear();
            SetPres();
        }

        //-----------------------------------UTILITY----------------------------------

        public static int PlayerCount() {
            return players.Length;
        }

        public static int[] ChancellorCandidates() {
            List<int> candidates = new List<int> ();
            for(int i = 0; i < PlayerCount(); i++) {
                if (PlayerCount() > 5) {
                    if (i != CurrentPrez && i != PrevPrez && i != PrevChan && !players[i].IsDead) {
                        candidates.Add(i);
                    }
                } else {
                    if (i != CurrentPrez && i != PrevChan && !players[i].IsDead) {
                        candidates.Add(i);
                    }
                }
            }
            return candidates.ToArray();
        }

        public static int[] LoyaltyCheckList() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (i != CurrentPrez && !players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }

        public static int[] SpecialElectionCandidates() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (i != CurrentPrez && !players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }

        public static int[] AssassinationList() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (!players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }
    }
}