using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;
using System.Threading;

namespace SecretHitler {
    
    public static class GameManager {
        public static SIZE gameSize;
        
        public static GAMESTATES gameState = GAMESTATES.NOT_STARTED;

        private static PoliciesDeck policies = new PoliciesDeck();

        private static PlayerLogic[] players;

        private static int PrevPrez = -1;     // For selecting special elections and chancellor selection
        private static int CurrentPrez = -1;  // For Drawing cards
        private static int NextPrez = -1;     // For president cycle
        private static int PrevChan = -1;     // For selecting chancellor
        private static int CurrentChan = -1;  // For Passing cards

        private static int ElectionTracker = 0;
        private static bool HitlerKnows = false;

        /// <summary>
        /// Adds player to array of players, will fail if game has already started
        /// ID is autogenerated
        /// </summary>
        /// <param name="Name">Display name of player</param>
        /// <returns>Successfully added player</returns>
        public static bool AddPlayer(string Name) {
            if (gameState != GAMESTATES.NOT_STARTED) {
                PlayerLogic[] newPlayerList = new PlayerLogic[PlayerCount() + 1];
                for (int i = 0; i < PlayerCount(); i++) {
                    newPlayerList[i] = players[i];
                }
                newPlayerList[PlayerCount()] = new PlayerLogic(PlayerCount(), Name);
                players = newPlayerList;
                return true;
            } else {
                return false;
            }
        }

        /// <summary>
        /// Used once all players have joined lobby
        /// </summary>
        public static void GameStart() {
            int playercount = PlayerCount();
            if (playercount < 5)
                return; // Too few players
            else if (playercount < 7) {
                gameSize = SIZE.SML;
                HitlerKnows = true;
            } else if (playercount < 9) {
                gameSize = SIZE.MED;
                HitlerKnows = false;
            } else if (playercount < 11) {
                gameSize = SIZE.LGE;
                HitlerKnows = false;
            } else
                return; // Too many players

                int[] randomPlayers = new int[playercount];
                for (int i = 0; i < playercount; i++) {
                    randomPlayers[i] = i;
                }
                randomPlayers.Shuffle();

                int pIndex = 0;
                //Set Hitler
                players[randomPlayers[pIndex]].Role = ROLES.Hitler;
                pIndex++;
                //Set fascists
                int numFascists = (playercount - 3) / 2;
                while (pIndex < numFascists) {
                    players[randomPlayers[pIndex]].Role = ROLES.Fascist;
                    pIndex++;
                }
                //Set remaining as Liberal
                while (pIndex < playercount) {
                    players[randomPlayers[pIndex]].Role = ROLES.Liberal;
                    pIndex++;
                }
                //Reset deck of cards
                policies = new PoliciesDeck();
                //Clear boards
                Boards.ClearAll();
                //Randomly select president
                System.Random rand = new System.Random();
                CurrentPrez = rand.Next(0, playercount - 1);
                SetNewNextPres(CurrentPrez + 1);
                //No need to make users communicate roles, as info will be available on devices

                gameState = GAMESTATES.READING_ROLES;
            }

        //----------------------------------GAME LOOP---------------------------------

        public static void Update() {
            switch (gameState) {
                case GAMESTATES.READING_ROLES:
                    bool done = true;
                    for (int i = 0; i < PlayerCount(); i++) {
                        if (!players[i].HasVoted)
                            done = false;
                    }
                    if (done) {
                        gameState = GAMESTATES.SELECTING_CHAN;
                    }
                    break;
                case GAMESTATES.VOTING:
                    int voteTotal = 0;
                    for (int i = 0; i < PlayerCount(); i++) {
                        if (!players[i].HasVoted)
                            return;
                        if (players[i].Vote == Utility.JA)
                            voteTotal++;
                        else
                            voteTotal--;
                    }
                    if(voteTotal > 0) {
                        if (players[CurrentChan].Role == ROLES.Hitler && Boards.FascistBoards[(int)gameSize].CardsPlayed >= 3) {
                            EndGame(Utility.FASCIST);
                        } else {
                            StartPres_Policy();
                        }
                    } else {
                        ElectionTracker++;
                        if (ElectionTracker > 3) {
                            AutoPlayCard(policies.drawCards(1)[0]);
                        } else {
                            SetPres();
                        }
                    }
                    break;
                case GAMESTATES.PRES_POLICY:
                    if (players[CurrentPrez].Hand.Count < 3) {
                        StartChan_Policy();
                    }
                    break;
                case GAMESTATES.CHAN_POLICY:
                    if (players[CurrentPrez].Hand.Count < 2) {
                        bool CardPlayed = players[CurrentChan].Hand[0];
                        players[CurrentChan].Hand.Clear();
                        PlayCard(CardPlayed);
                    }
                    break;
            }
        }

        private static void SetPres() {
            CurrentPrez = NextPrez;
            SetNewNextPres(CurrentPrez + 1);
            gameState = GAMESTATES.SELECTING_CHAN;
        }

        private static int SetNewNextPres(int nextPresID) {
            NextPrez = nextPresID % PlayerCount();
            return NextPrez;
        }

        private static void StartPres_Policy() {
            players[CurrentPrez].Hand = policies.drawCards(3);
        }

        private static void StartChan_Policy() {
            players[CurrentChan].Hand = players[CurrentPrez].Hand;
        }

        private static void PlayCard(bool c) {
            PrevChan = CurrentChan;
            PrevPrez = CurrentPrez;

            if (c == Utility.FASCIST) {
                Boards.FascistBoards[(int)gameSize].CardsPlayed++;
                if (Boards.FascistBoards[(int)gameSize].CardsPlayed == Boards.FascistBoards[(int)gameSize].BoardLength()) {
                    EndGame(Utility.FASCIST);
                } else {
                    ResolvePowers(Boards.FascistBoards[(int)gameSize].GetPower());
                }
             } else {
                Boards.LiberalBoard.CardsPlayed++;
                if (Boards.LiberalBoard.CardsPlayed == Boards.LiberalBoard.BoardLength()) {
                    EndGame(Utility.LIBERAL);
                } else {
                    ResolvePowers(Boards.LiberalBoard.GetPower());
                }
            }

            ElectionTracker = 1;
        }

        private static void AutoPlayCard(bool c) {
            PrevChan = -1;
            PrevPrez = -1;

            if (c == Utility.FASCIST) {
                Boards.FascistBoards[(int)gameSize].CardsPlayed++;
                if (Boards.FascistBoards[(int)gameSize].CardsPlayed == Boards.FascistBoards[(int)gameSize].BoardLength()) {
                    EndGame(Utility.FASCIST);
                } else {
                    SetPres();
                }
            } else {
                Boards.LiberalBoard.CardsPlayed++;
                if (Boards.LiberalBoard.CardsPlayed == Boards.LiberalBoard.BoardLength()) {
                    EndGame(Utility.LIBERAL);
                } else {
                    SetPres();
                }
            }

            ElectionTracker = 1;
        }

        private static void ResolvePowers (POWERS p) {
            switch (p) {
                case POWERS.LoyaltyCheck:
                    gameState = GAMESTATES.LOYALTY_CHECK;
                    break;
                case POWERS.SpecialElection:
                    gameState = GAMESTATES.SPECIAL_ELECTION;
                    break;
                case POWERS.PolicyCheck:
                    gameState = GAMESTATES.POLICY_PEEK;
                    players[CurrentPrez].Hand = policies.showTopThree();
                    break;
                case POWERS.Assassination:
                    gameState = GAMESTATES.ASSASSINATE;
                    break;
                default:
                    SetPres();
                    break;
            }
        }

        private static void EndGame(bool whoWon) {
            gameState = GAMESTATES.ENDED;
        }

        //-----------------------------------ACTIONS----------------------------------

        public static void DiscardCard (int PlayerID, int index) {
            policies.discard(players[PlayerID].Hand[index]);
            players[PlayerID].Hand.Remove(players[PlayerID].Hand[index]);
        }

        public static void KillPlayer(int PlayerID) {
            players[PlayerID].IsDead = true;
            if(players[PlayerID].Role == ROLES.Hitler) {
                EndGame(Utility.LIBERAL);
            } else {
                SetPres();
            }
        }

        public static void ChooseChancellor(int PlayerID) {
            CurrentChan = PlayerID;
            gameState = GAMESTATES.VOTING;
            foreach (PlayerLogic p in players)
                p.HasVoted = false;
        }

        public static void ChoosePresident(int PlayerID) {
            CurrentPrez = PlayerID;
            gameState = GAMESTATES.SELECTING_CHAN;
        }

        public static void Vote (int PlayerID, bool vote) {
            players[PlayerID].Vote = vote;
        }

        public static void StartVeto() {
            gameState = GAMESTATES.VETOING;
        }

        public static void EndVeto(bool Vote) {
            if (Vote == Utility.JA) {
                policies.discard(players[CurrentChan].Hand[0]);
                policies.discard(players[CurrentChan].Hand[1]);
                players[CurrentChan].Hand.Clear();
                ElectionTracker++;
                SetPres();
            } else {
                gameState = GAMESTATES.CHAN_POLICY;
            }
        }

        public static void EndPolicyPeek () {
            players[CurrentPrez].Hand.Clear();
            SetPres();
        }

        //-----------------------------------UTILITY----------------------------------

        public static int PlayerCount() {
            return players.Length;
        }

        public static int[] GetFascistList(int ID) {
            List<int> fascists = new List<int>();
            if(players[ID].Role == ROLES.Liberal || players[ID].Role == ROLES.Hitler && !HitlerKnows) {
                fascists.Add(ID);
                return fascists.ToArray();
            }
            for (int i = 0; i < PlayerCount(); i++) {
                if (players[i].Role >= ROLES.Fascist) {
                    fascists.Add(i);
                }
            }
            return fascists.ToArray();
        }

        public static int[] ChancellorCandidates() {
            List<int> candidates = new List<int> ();
            for(int i = 0; i < PlayerCount(); i++) {
                if (PlayerCount() > 5) {
                    if (i != CurrentPrez && i != PrevPrez && i != PrevChan && !players[i].IsDead) {
                        candidates.Add(i);
                    }
                } else {
                    if (i != CurrentPrez && i != PrevChan && !players[i].IsDead) {
                        candidates.Add(i);
                    }
                }
            }
            return candidates.ToArray();
        }

        public static int[] LoyaltyCheckList() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (i != CurrentPrez && !players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }

        public static int[] SpecialElectionCandidates() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (i != CurrentPrez && !players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }

        public static int[] AssassinationList() {
            List<int> candidates = new List<int>();
            for (int i = 0; i < PlayerCount(); i++) {
                if (!players[i].IsDead) {
                    candidates.Add(i);
                }
            }
            return candidates.ToArray();
        }
    }
}